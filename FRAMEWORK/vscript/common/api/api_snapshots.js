"use strict";Object.defineProperty(exports,"__esModule",{value:!0});const api_reflection_1=require("./api_reflection"),api_base_1=require("./api_base"),fs=require("fs-extra"),path=require("path"),child_process_1=require("child_process");async function retrieve_snapshot(e){let i=!1;try{if(fs.existsSync(e.snapshot_dir))throw`Directory ${e.snapshot_dir} already exists, refusing to overwrite`;api_base_1.inform("Determining selected fpga...");const s=await api_base_1.selected_application(e.ip);if(void 0===s)throw`Unable to determine selected FPGA @${e.ip}; this is required for on-demand ip config generation`;const o=void 0!==e.generate_ip_config_if_missing&&e.generate_ip_config_if_missing,t=async()=>{api_base_1.inform("Checking current IP config...");const i=child_process_1.execSync(`ssh root@${e.ip} 'ls /config/'`).toString().split("\n").map(e=>e.trim()).filter(e=>null!==e.match(/^ip_.*\.sh$/)),o=null!==s.toLowerCase().match(/40gbe$/);api_base_1.inform(`Machine ${e.ip} is configured to run in ${o?"40":"10"}G mode`);const t=["1","3","0.0","2.0"].concat(o?[]:["0.1","0.2","0.3","2.1","2.2","2.3"]),n=(()=>{let e=[];for(let s of t)i.includes(`ip_eth${s}.sh`)||e.push(s);return e})();return 0===n.length||(api_base_1.inform(`Machine ${e.ip} lacks IP config files for ${n.length} interface(s): ${n.map(e=>"eth_"+e).join(", ")}. Attempting to generate missing config files (set generate_ip_config_if_missing to false to disable this)...`),await api_base_1.dispatch_change_request("network_interfaces","save_config","Click",e.ip),await api_base_1.pause(1),!1)};if(o){const e=5;let i=!1;for(let s=0;s<e&&!(i=await t());s++);if(!i)throw`After failing to generate missing IP config files ${e} times in a row, snapshot generation will be aborted`}const n=(i,s)=>{child_process_1.execSync(`scp -rp root@${e.ip}:${i} '${s}'`)},a=await api_reflection_1.get_build_info(e.ip);fs.mkdirpSync(e.snapshot_dir);const r=path.join(e.snapshot_dir,"build_info.json");fs.writeJSONSync(r,a,{spaces:4}),fs.writeJSONSync(path.join(e.snapshot_dir,"snapshot_info.json"),{creation_date:new Date,selected_fpga:s}),e.kill_processes&&(api_base_1.warn(`stopping operating software @ ${e.ip} as requested...`),i=!0,child_process_1.execSync(`ssh "root@${e.ip}" "systemctl stop vmatrix*"`)),api_base_1.inform("Trying to download /config..."),n("/config",e.snapshot_dir),child_process_1.execSync(`ssh "root@${e.ip}" "dd if=/dev/mtd/by-name/general of=/tmp/nvram-snapshot.img"`),api_base_1.inform("Trying to download NVRAM snapshot");const p=path.join(e.snapshot_dir,"nvram-snapshot.img");n("/tmp/nvram-snapshot.img",p);const c=fs.statSync(p).size,_=523136;if(c!==_)throw fs.removeSync(e.snapshot_dir),`Received incorrect size for NVRAM snapshot (${c}, should be ${_})`}finally{i&&(api_base_1.warn(`rebooting ${e.ip} to restart operating software...`),child_process_1.execSync(`ssh "root@${e.ip}" reboot`))}}async function restore_snapshot(e){let i=!1;try{try{child_process_1.execSync(`ssh root@${e.ip} ./get_mac_address`)}catch(i){if(0!==i.status)throw i.stderr.toString().match(/Unable to read PCBInfo/)?"The target machine's EPROM contains no MAC address; please contact customer support.":`Unable to determine whether the target machine's EPROM is programmed correctly; please check whether it can be reached via 'ssh root@${e.ip}'`}const s=(i,s)=>{child_process_1.execSync(`scp -rp '${i}' 'root@${e.ip}:${s}'`)},o=path.join(e.snapshot_dir,"build_info.json"),t=await api_base_1.selected_application(e.ip),n=fs.readJSONSync(path.join(e.snapshot_dir,"snapshot_info.json")),a=["multiviewer","streaming","multiviewer_40gbe","streaming_40gbe"];if(void 0===n.selected_fpga)throw"snapshot_info.json specifies no FPGA variant";if(!a.includes(n.selected_fpga))throw`snapshot_info.json mentions unknown FPGA variant '${n.selected_fpga}'`;t!==n.selected_fpga&&(api_base_1.inform(`Selecting FPGA '${n.selected_fpga}'...`),await api_base_1.select_application(n.selected_fpga,e.ip));const r=path.join(e.snapshot_dir,"config"),p=path.join(r,"vmatrix"),c=path.join(r,"rsyslog"),_=path.join(e.snapshot_dir,"nvram-snapshot.img"),h=fs.readJSONSync(o),f=await api_reflection_1.get_build_info(e.ip);if(f.version!==h.version)throw`Unable to restore snapshot: installed software version is ${f.version} (should be ${h.version})`;if(f.commit!==h.commit)throw`Unable to restore snapshot: installed software is derived from hg commit #${f.commit} (should be ${h.commit})`;const l=fs.statSync(_).size,d=523136;if(l!==d)throw`Received incorrect size for NVRAM snapshot (${l}, should be ${d})`;api_base_1.warn(`stopping operating software @ ${e.ip}...`),child_process_1.execSync(`ssh "root@${e.ip}" "systemctl stop vmatrix*"`),i=!0,api_base_1.inform("Trying to upload config/vmatrix..."),s(p,"/config/"),api_base_1.inform("Trying to upload config/rsyslog..."),s(c,"/config/");const g=fs.readdirSync(r);e.include_ip_config&&(g.findIndex(e=>null!==e.match(/^ip_.*\.sh$/))>=0?(api_base_1.inform("Trying to upload network config..."),child_process_1.execSync(`cd '${r}' && scp -p ip_*.sh 'root@${e.ip}:/config/'`)):api_base_1.warn("Unable to restore IP config (snapshot contains no ip_*.sh file)")),e.include_hostname&&(g.includes("hostname")?(api_base_1.inform("Trying to upload hostname..."),s(path.join(r,"hostname"),"/config/")):api_base_1.warn("Unable to restore hostname (snapshot contains no hostname file)")),api_base_1.inform("Trying to upload NVRAM snapshot..."),await s(_,"/tmp/nvram-snapshot.img"),api_base_1.inform("Trying to overwrite NVRAM..."),child_process_1.execSync(`ssh "root@${e.ip}" "dd of=/dev/mtd/by-name/general if=/tmp/nvram-snapshot.img"`)}finally{i&&(api_base_1.inform(`Rebooting ${e.ip}...`),child_process_1.execSync(`ssh "root@${e.ip}" reboot`))}}exports.retrieve_snapshot=retrieve_snapshot,exports.restore_snapshot=restore_snapshot;