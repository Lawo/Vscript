"use strict";Object.defineProperty(exports,"__esModule",{value:!0});const multi_connection_1=require("../multi_connection"),pervasives_1=require("../pervasives"),api_base_1=require("./api_base");async function create_unnamed_table_row(e,t,a){let n=await multi_connection_1.get().get_connection_or_default(a);const i=a&&a.timeout?a.timeout:60;let o=await n.allocated_indices(e),r=o;const _=async()=>(r=await n.allocated_indices(e)).length>o.length,l=(()=>{if("string"==typeof t){const e=pervasives_1.path_parent(t),a=pervasives_1.path_base(t);return()=>{n.dispatch_change_request(e,a,"Click")}}return t})();await(async()=>{const e=1e3*i/1e3;for(let t=0;t<e;++t){await l();for(let e=0;e<20;++e){if(await _())return;await api_base_1.pause_ms(50)}}})(),r.length<=o.length&&api_base_1.fail(`after failing to allocate a new row within table '${e}', execution will be aborted`);const c=(a?a.accept_overallocation:void 0)||!1;return(()=>{const a=new Set(o),n=r.filter(e=>!a.has(e));if(n.length>1&&!0!==c)throw`allocate_table_row(${e}, ${t}): returned set of allocated indices contains several (${n.length}) new elements`;return n[0]})()}async function delete_unnamed_table_row(e,t,a,n){let i=await multi_connection_1.get().get_connection_or_default(n);const o=n&&n.timeout?n.timeout:60;let r=await i.allocated_indices(e);if(!r.includes(t))return;let _=r;const l=async()=>(_=await i.allocated_indices(e)).length<r.length,c=(()=>{const e=pervasives_1.path_parent(a),t=pervasives_1.path_base(a);return()=>{i.dispatch_change_request(e,t,"Click")}})();await(async()=>{const e=1e3*o/1e3;for(let t=0;t<e;++t){await c();for(let e=0;e<20;++e){if(await l())return;await api_base_1.pause_ms(50)}}})(),_.length>=r.length&&api_base_1.fail(`after failing to delete row #${t} within table '${e}', execution will be aborted`);const s=new Set(_),u=r.filter(e=>!s.has(e));if(u.length>1)throw`delete_table_row(${e}, ${a}): inadvertently deleted multiple elements`;if(u[0]!==t)throw`delete_table_row(${e}, ${a}): deleted the wrong element (index #${u[0]} instead of ${t})`}async function create_or_reuse_table_row(e,t,a,n){let i=await multi_connection_1.get().get_connection_or_default(n);const o=n?n.index:void 0;if(void 0===o){const t=await i.allocated_indices(e);if(t.length>0)return a(t[0],i.connection_pars.ip)}else if(await i.is_allocated(e,o))return a(o,i.connection_pars.ip);for(;;){const n=await create_unnamed_table_row(e,t,{ip:i.connection_pars.ip});if(void 0===o||n===o)return a(n,i.connection_pars.ip)}}async function used_rows(e,t){let a=await multi_connection_1.get().get_connection_or_default(t);return(await a.allocated_indices(e)).map(t=>`${e}[${t}]`)}exports.create_unnamed_table_row=create_unnamed_table_row,exports.delete_unnamed_table_row=delete_unnamed_table_row,exports.create_or_reuse_table_row=create_or_reuse_table_row,exports.used_rows=used_rows;