"use strict";Object.defineProperty(exports,"__esModule",{value:!0});const pervasives_1=require("../pervasives"),calling_conventions_1=require("./calling_conventions"),api_reflection_1=require("../api/api_reflection");class SavedAnonymousSubtree{constructor(e,t,a){this.full_kwl_name=e,this.kw=t,this.kwl=a}with_kwl_name(e){return new SavedAnonymousSubtree(e,this.kw,this.kwl)}static lift(e,t){const a=t.kw||{};let n={};if(void 0!==t.kwl)for(const a in t.kwl)t.kwl[a].hasOwnProperty("named-rows")?n[a]=SavedNamedTable.lift(pervasives_1.path_concat(e,a),t.kwl[a]):n[a]=SavedAnonymousSubtree.lift(pervasives_1.path_concat(e,a),t.kwl[a]);return new SavedAnonymousSubtree(e,a,n)}empty(){return 0===Object.keys(this.kw).length&&0===Object.keys(this.kwl).length}map(e){const t=e.recursion_depth;let a={};for(const t in this.kw){if(null===this.kw[t]){!t.toLowerCase().match(/thumbnail/)&&this.full_kwl_name.match(/thumbnail/);continue}const n=e.f_kw({full_kwl_name:this.full_kwl_name,name:t,data:this.kw[t].data,isDefault:this.kw[t].isDefault||!1});void 0!==n&&(a[t]=Object.assign({},this.kw[t],{data:n}))}let n={};for(const a in this.kwl){let s=e.f_kwl({full_kwl_name:pervasives_1.path_concat(this.full_kwl_name,a),name:a,data:this.kwl[a]});void 0!==s&&(0!==t&&((s=s.map(Object.assign({},e,{recursion_depth:e.recursion_depth-1}))).empty()||(n[a]=s)))}return new SavedAnonymousSubtree(this.full_kwl_name,a,n)}filter(e){const t=e.recursion_depth;let a={};for(const t in this.kw)null!==this.kw[t]&&!1!==e.f_kw({full_kwl_name:this.full_kwl_name,name:t,data:this.kw[t].data,isDefault:this.kw[t].isDefault||!1})&&(a[t]=this.kw[t]);let n={};for(const a in this.kwl){const s=e.f_kwl({full_kwl_name:pervasives_1.path_concat(this.full_kwl_name,a),name:a,data:this.kwl[a]});if(!0===s){n[a]=this.kwl[a];continue}if(!1===s)continue;if(0===t)continue;const i=this.kwl[a].filter(Object.assign({},e,{recursion_depth:e.recursion_depth-1}));i.empty()||(n[a]=i)}return new SavedAnonymousSubtree(this.full_kwl_name,a,n)}read(e,t){if(0===e.length)return this;const[a,n]=[pervasives_1.path_hd(e),pervasives_1.path_tl(e)];if(0===n.length&&this.kw.hasOwnProperty(a))return this.kw[a];const s=void 0===t?a:pervasives_1.path_concat(t,a);return this.kwl.hasOwnProperty(a)?this.kwl[a].read(n,s):this.kwl.hasOwnProperty(pervasives_1.remove_trailing_index(a))?this.kwl[pervasives_1.remove_trailing_index(a)].read(n,s):void 0}async serialize_unnamed(e,t,a){let n={kw:{},kwl:{}};for(const s in this.kw)if(!1===e||!this.kw[s].hasOwnProperty("isDefault")){const e=t.get_keyword_description(this.full_kwl_name,s),i=this.kw[s].data;switch(e.kw_type){case"command":case"driver-owned event":case"event":case"status":n.kw[s]=i;break;case"duplex":if(a){const e=s.replace(/_(status|command)$/,"");n.kw[`${e}_command`]=await a({full_kwl_name:this.full_kwl_name,name:e,status:this.kw[`${e}_status`],command:this.kw[`${e}_command`]})}else n.kw[s]=i}}const s=async(n,s,i)=>{const o=await s.serialize_unnamed(e,t,a);void 0!==o&&(i.kwl[n]=o)},i=e=>0===Object.keys(e.kwl).length&&0===Object.keys(e.kw).length;for(const e in this.kwl)if(this.kwl[e]instanceof SavedAnonymousSubtree)await s(e,this.kwl[e],n);else{let t={kw:{},kwl:{}};for(const a of this.kwl[e].rows)await s(pervasives_1.path_base(a.data.full_kwl_name),a.data,t);i(t)||(n.kwl[pervasives_1.path_base(this.kwl[e].full_kwl_name)]=t)}return i(n)?void 0:n}async scaffold(e,t){for(const a in this.kwl)if("]"===a[a.length-1]&&t.workspace.is_table(pervasives_1.path_concat(this.full_kwl_name,a))){const n=pervasives_1.path_concat(e,a),s=pervasives_1.remove_all_indices(n);if(!t.unnamed_row_creators.hasOwnProperty(s))throw`Unable to create row within branch '${s}' (no matching unnamed_row_creator has been defined)`;const i=t.unnamed_row_creators[s],o=pervasives_1.path_concat(e,pervasives_1.remove_trailing_index(a)),l=(pervasives_1.index_of_kwl_name(a),await i(o));if(null===l)throw`Unable to create row within unnamed table '${o}'`;const r=pervasives_1.attach_index(pervasives_1.remove_trailing_index(o),l);r!==n&&t.workspace.register_kwl_relocation(n,r),await this.kwl[a].scaffold(r,t)}else await this.kwl[a].scaffold(pervasives_1.path_concat(e,a),t)}apply_relocations(e,t){const a=t.nested||{};let n={};const s=(e,t)=>{if(n.hasOwnProperty(e))throw`Renaming conflict: '${e}' is already occupied`;n[e]=t};for(const t in this.kwl){let n=t;a.hasOwnProperty(t)&&a[t].hasOwnProperty("new_local_name")&&(n=a[t].new_local_name),s(n,this.kwl[t].apply_relocations(pervasives_1.path_concat(e,n),a[t]||{}))}return this.full_kwl_name,new SavedAnonymousSubtree(e,this.kw,n)}async undump(e){const t=await this.serialize_unnamed(calling_conventions_1.skip_defaults(e),e.workspace,e.disambiguate_duplex);void 0!==t&&e.connection.send_tree(this.full_kwl_name,t)}merge(e){if(e.full_kwl_name!==this.full_kwl_name)throw"refusing to merge subtrees with different kwl names";let t=Object.assign({},this.kw);for(const a in e.kw){if(t.hasOwnProperty(a))throw`merge conflict: both subtrees contain a keyword named '${a}'`;t[a]=e.kw[a]}let a=Object.assign({},this.kwl);for(const t in e.kwl){if(a.hasOwnProperty(t))throw`merge conflict: both subtrees contain a keyword list named '${t}'`;a[t]=e.kwl[t]}return new SavedAnonymousSubtree(this.full_kwl_name,t,a)}diff(e,t){let a={only_in_old:new SavedAnonymousSubtree(this.full_kwl_name,{},{}),only_in_new:new SavedAnonymousSubtree(e.full_kwl_name,{},{}),modified:new SavedAnonymousSubtree(e.full_kwl_name,{},{}),unmodified:new SavedAnonymousSubtree(this.full_kwl_name,{},{})};for(const n in this.kw)e.kw.hasOwnProperty(n)?t(this.full_kwl_name,n,this.kw[n],e.kw[n])?a.unmodified.kw[n]=this.kw[n]:a.modified.kw[n]=e.kw[n]:a.only_in_old.kw[n]=this.kw[n];for(const t in e.kw)this.kw.hasOwnProperty(t)||(a.only_in_new.kw[t]=e.kw[t]);const n=(e,t)=>{for(const n in t)void 0===t[n]||t[n].empty()||(a[n].kwl.hasOwnProperty(e)?(t[n],a[n].kwl[e]=a[n].kwl[e].merge(t[n])):a[n].kwl[e]=t[n])};for(const s in this.kwl)e.kwl.hasOwnProperty(s)?this.kwl[s]instanceof SavedAnonymousSubtree&&e.kwl[s]instanceof SavedAnonymousSubtree?n(s,this.kwl[s].diff(e.kwl[s],t)):this.kwl[s]instanceof SavedNamedTable&&e.kwl[s]instanceof SavedNamedTable?n(s,this.kwl[s].diff(e.kwl[s],t)):(a.only_in_old.kwl[s]=this.kwl[s],a.only_in_new.kwl[s]=e.kwl[s]):a.only_in_old.kwl[s]=this.kwl[s];for(const t in e.kwl)this.kwl.hasOwnProperty(t)||(a.only_in_new.kwl[t]=this.kwl[t]);return a}static async random(e,t,a){const n=api_reflection_1.get_subtree_description(e,pervasives_1.remove_all_indices(t));let s={},i={};const o=void 0===a||void 0===a.allow_duplex_mismatch||a.allow_duplex_mismatch,l=async n=>{if(a&&a.skip_node_randomization_if&&await a.skip_node_randomization_if(n,t))return;if("atomic subtree"===n.data_type)return;const i=a=>({data:api_reflection_1.random_content(t,a,e.state)}),l=a&&a.custom_node_randomizer?async e=>{const n=await a.custom_node_randomizer(e,t);return void 0===n?i(e):n}:async e=>i(e);if("duplex"===n.kw_type){const e=await l(Object.assign({},n,{kw_type:"status"}));s[n.sys_name+"_status"]=e,s[n.sys_name+"_command"]=o?await l(Object.assign({},n,{kw_type:"command"})):e}else s[n.sys_name]=await l(n)};for(const s of n.children)if("subtree"===s.data_type){if(a&&a.skip_subtree_randomization_if&&await a.skip_subtree_randomization_if(s,t))continue;if(s.array_size)for(let n=0;n<s.array_size;++n)i[pervasives_1.attach_index(s.sys_name,n)]=await SavedAnonymousSubtree.random(e,pervasives_1.path_concat(t,pervasives_1.attach_index(s.sys_name,n)),a);else if(s.table_size){const n=api_reflection_1.random_indices({table_size:s.table_size,n:api_reflection_1.random_int(0,s.table_size,{nullable:!1})});let o=[];for(const i of n)o.push([i,await SavedAnonymousSubtree.random(e,pervasives_1.path_concat(t,pervasives_1.attach_index(s.sys_name,i)),a)]);if(s.named_rows){const e=pervasives_1.path_concat(t,s.sys_name);i[s.sys_name]=new SavedNamedTable(e,o.map(([t,a])=>new SavedNamedRow(e,`row #${t}`,t,a)))}else for(const[e,t]of o)i[pervasives_1.attach_index(s.sys_name,e)]=t}else i[s.sys_name]=await SavedAnonymousSubtree.random(e,pervasives_1.path_concat(t,s.sys_name),a)}else await l(s);return new SavedAnonymousSubtree(t,s,i)}}exports.SavedAnonymousSubtree=SavedAnonymousSubtree;class SavedNamedTable{constructor(e,t){this.full_kwl_name=e,this.rows=t}static lift(e,t){return new SavedNamedTable(e,t["named-rows"].map(t=>SavedNamedRow.lift(e,t)))}empty(){return 0===this.rows.length}map(e){let t=[];for(const a of this.rows){if(0===e.recursion_depth){t.push(a);continue}let n=a.map(Object.assign({},e,{recursion_depth:e.recursion_depth-1}));void 0===n||n.empty()||t.push(n)}return new SavedNamedTable(this.full_kwl_name,t)}filter(e){let t=[];for(const a of this.rows){const n=e.f_kwl({full_kwl_name:a.data.full_kwl_name,name:a.id,data:a});if(!0===n){t.push(a);continue}if(!1===n)continue;if(0===e.recursion_depth)continue;const s=a.filter(Object.assign({},e,{recursion_depth:e.recursion_depth-1}));s.empty()||t.push(s)}return new SavedNamedTable(this.full_kwl_name,t)}read(e,t){if(0===e.length)return this;const[a,n]=[pervasives_1.path_hd(e),pervasives_1.path_tl(e)],s=void 0===t?a:pervasives_1.path_concat(t,a),i=pervasives_1.path_base(this.full_kwl_name);for(const e of this.rows)if(a===`${i}[${e.idx}]`||a===`${i}["${e.id}"]`)return e.read(n,s)}async scaffold(e,t){for(const a of this.rows){const n=await t.connection.create_table_row(e,{desired_index:a.idx,desired_name:a.id});if(null===n)throw`Unable to allocate table row '${this.full_kwl_name}["${a.id}"]' @ index ${a.idx}'`;await a.data.scaffold(pervasives_1.attach_index(e,n[0]),t)}}apply_relocations(e,t){const a=pervasives_1.path_base(this.full_kwl_name),n=t.nested||{},s=this.rows.map(t=>{const s=[pervasives_1.attach_index(a,t.idx),`${a}["${t.id}"]`],i=s.map(e=>n.hasOwnProperty(e)&&n[e].hasOwnProperty("new_local_name")?n[e].new_local_name:e);if(s[0]!==i[0]&&s[1]!==i[1])throw`Renaming conflict: ${s[0]} maps to ${i[0]}, but the (equivalent) identifier ${s[1]} maps to ${i[1]}`;const o=pervasives_1.index_of_kwl_name(i[0]),l=(()=>n.hasOwnProperty(s[0])?n[s[0]]:n.hasOwnProperty(s[0])?n[s[1]]:{})(),r=pervasives_1.path_concat(pervasives_1.path_parent(e),i[0]);return new SavedNamedRow(e,t.id,o,t.data.apply_relocations(r,l))});return new SavedNamedTable(e,s)}async undump(e){for(const t of this.rows)await t.undump(e)}diff(e,t){let a={only_in_old:new SavedNamedTable(this.full_kwl_name,[]),only_in_new:new SavedNamedTable(e.full_kwl_name,[]),modified:new SavedNamedTable(e.full_kwl_name,[]),unmodified:new SavedNamedTable(this.full_kwl_name,[])};const n=(e,t,a)=>{for(const n of a)if(n.id===t&&n.idx===e)return n};for(const s of this.rows){const i=n(s.idx,s.id,e.rows);if(void 0===i)a.only_in_old.rows.push(s);else{const e=s.data.diff(i.data,t),n=(e,t)=>{void 0!==t&&e.rows.push(new SavedNamedRow(this.full_kwl_name,s.id,s.idx,t))};n(a.only_in_old,e.only_in_old),n(a.only_in_new,e.only_in_new),n(a.modified,e.modified),n(a.unmodified,e.unmodified)}}for(const t of e.rows){void 0===n(t.idx,t.id,this.rows)&&a.only_in_new.rows.push(t)}return a}merge(e){if(e.full_kwl_name!==this.full_kwl_name)throw"refusing to merge named tables with different kwl names";let t={};for(const e of this.rows)t[e.idx]=e;for(const a of e.rows)if(t.hasOwnProperty(a.idx)){if(t[a.idx].id!==a.id)throw`ID conflict: new row named '${a.id}' shares index with old row named '${t[a.idx].id}`;t[a.idx].data=t[a.idx].data.merge(a.data)}else t[a.idx]=a;return new SavedNamedTable(this.full_kwl_name,Object.entries(t).map(([e,t])=>t))}}exports.SavedNamedTable=SavedNamedTable;class SavedNamedRow{constructor(e,t,a,n){this.table_kwl_name=e,this.id=t,this.idx=a,this.data=n}static lift(e,t){return new SavedNamedRow(e,t.id,t.idx,SavedAnonymousSubtree.lift(pervasives_1.attach_index(e,t.idx),t))}empty(){return this.data.empty()}map(e){return new SavedNamedRow(this.table_kwl_name,this.id,this.idx,this.data.map(e))}filter(e){return new SavedNamedRow(this.table_kwl_name,this.id,this.idx,this.data.filter(e))}read(e,t){return this.data.read(e,t)}async undump(e){await this.data.undump(e)}}exports.SavedNamedRow=SavedNamedRow;